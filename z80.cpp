#include "std.h"

#include "z80.h"
#include "memory.h"
#include "device.h"

namespace xZ80
{

byte even_m1 = 0;
bool unstable_databus = false;

//=============================================================================
//	eZ80::eZ80
//-----------------------------------------------------------------------------
eZ80::eZ80() : t(0), im(0), eipos(0), haltpos(0), frame_tacts(0), last_branch(0)
{
	pc = sp = ir = memptr = ix = iy = 0;
	bc = de = hl = af = alt.bc = alt.de = alt.hl = alt.af = 0;
	int_flags = 0;
}
//=============================================================================
//	eZ80::Init
//-----------------------------------------------------------------------------
void eZ80::Init()
{
	InitOpNoPrefix();
	InitOpCB();
	InitOpDD();
	InitOpED();
	InitOpFD();
	InitOpDDCB();
	InitTables();
}
//=============================================================================
//	eZ80::Reset
//-----------------------------------------------------------------------------
void eZ80::Reset()
{
	int_flags = 0;
	ir = 0;
	im = 0;
	pc = 0;
	last_branch = 0;
}
//=============================================================================
//	eZ80::Fetch
//-----------------------------------------------------------------------------
byte eZ80::Fetch()
{
	r_low++;// = (cpu->r & 0x80) + ((cpu->r+1) & 0x7F);
	t += 4;
	return Read(pc++);
}
//=============================================================================
//	eZ80::Out
//-----------------------------------------------------------------------------
void eZ80::Out(dword port, byte v)
{
	devices.IoWrite(port, v);
}
//=============================================================================
//	eZ80::In
//-----------------------------------------------------------------------------
byte eZ80::In(dword port) const
{
	return devices.IoRead(port);
}
//=============================================================================
//	eZ80::Write
//-----------------------------------------------------------------------------
void eZ80::Write(word addr, byte v)
{
	memory.Write(addr, v);
}
//=============================================================================
//	eZ80::Read
//-----------------------------------------------------------------------------
byte eZ80::Read(word addr) const
{
	return memory.Read(addr);
}
//=============================================================================
//	eZ80::Int
//-----------------------------------------------------------------------------
void eZ80::Int()
{
	byte vector = 0xff; //unstable_databus ? (byte)rdtsc() : 0xFF;
	word intad = 0x38;
	if(im >= 2) // im2
	{ 
		word vec = vector + i*0x100;
		intad = Read(vec) + 0x100*Read(vec+1);
	}
	t += (im < 2) ? 13 : 19;
	Write(--sp, pc_h);
	Write(--sp, pc_l);
	pc = intad;
	memptr = intad;
	halted = 0;
	iff1 = iff2 = 0;
}
//=============================================================================
//	eZ80::Nmi
//-----------------------------------------------------------------------------
void eZ80::Nmi()
{
	Write(--sp, pc_h);
	Write(--sp, pc_l);
	pc = 0x66;
	iff1 = halted = 0;
}
//=============================================================================
//	eZ80::Step
//-----------------------------------------------------------------------------
void eZ80::Step()
{
	if(pc_h & even_m1) //wait
	{
		t += t & 1;
	}
	byte opcode = Fetch();
	(this->*normal_opcodes[opcode])();
}

}//namespace xZ80
